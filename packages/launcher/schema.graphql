input AcceptContactRequestInput {
  peerID: String!
  userID: String!
  clientMutationId: String
}

type AcceptContactRequestPayload {
  viewer: User!
  contact: Contact
  clientMutationId: String
}

input AddContactInput {
  publicID: String!
  aliasName: String
  sendInvite: Boolean
  clientMutationId: String
}

type AddContactPayload {
  contact: Contact
  viewer: User!
  clientMutationId: String
}

input AddHDWalletAccountInput {
  walletID: String!
  index: Int!
  clientMutationId: String
}

type AddHDWalletAccountPayload {
  address: String!
  viewer: User!
  clientMutationId: String
}

input AddLedgerWalletAccountsInput {
  indexes: [Int]
  name: String!
  userID: String
  setAsDefault: Boolean
  legacyPath: Boolean
  clientMutationId: String
}

type AddLedgerWalletAccountsPayload {
  ledgerWallet: EthLedgerWallet
  viewer: User!
  clientMutationId: String
}

type App implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  versions: [AppVersion!]!
}

type AppApprovedContact {
  aliasID: ID!
  contactID: ID!
}

input AppCreateMutationInput {
  name: String!
  contentsPath: String!
  version: String!
  developerID: String!
  permissionsRequirements: AppPermissionsRequirementsInput!
  clientMutationId: String
}

type AppCreateMutationPayload {
  app: OwnApp!
  viewer: User!
  clientMutationId: String
}

input AppCreateVersionMutationInput {
  appID: String!
  version: String!
  clientMutationId: String
}

type AppCreateVersionMutationPayload {
  app: OwnApp!
  viewer: User!
  clientMutationId: String
}

enum AppInstallationState {
  PENDING
  DOWNLOADING
  FAILED
  DONE
}

input AppInstallMutationInput {
  userID: String!
  manifest: AppManifestInput!
  permissionsSettings: AppPermissionsSettingsInput!
  clientMutationId: String
}

type AppInstallMutationPayload {
  app: App
  viewer: User!
  clientMutationId: String
}

type AppManifest {
  publicFeed: String!
  authorFeed: String!
  profile: GenericProfile!
  version: String!
  contentsHash: String!
  permissions: AppPermissionsRequirements!
}

input AppManifestInput {
  id: String!
  name: String!
  version: String!
  contentsHash: String!
  updateHash: String!
  permissions: AppPermissionsRequirementsInput!
  author: ManifestAuthorInput!
}

type AppPermissionDefinitions {
  WEB_REQUEST: [String]
  BLOCKCHAIN_SEND: Boolean
  COMMS_CONTACT: Boolean
  CONTACTS_READ: Boolean
}

input AppPermissionDefinitionsInput {
  BLOCKCHAIN_SEND: Boolean
  COMMS_CONTACT: Boolean
  CONTACTS_READ: Boolean
  WEB_REQUEST: [String]
}

type AppPermissions {
  BLOCKCHAIN_SEND: Boolean
  COMMS_CONTACT: Boolean
  CONTACTS_READ: Boolean
  WEB_REQUEST: WebRequestGrants!
}

type AppPermissionsRequirements {
  optional: AppPermissionDefinitions!
  required: AppPermissionDefinitions!
}

input AppPermissionsRequirementsInput {
  optional: AppPermissionDefinitionsInput!
  required: AppPermissionDefinitionsInput!
}

input AppPermissionsSettingsInput {
  permissionsChecked: Boolean!
  grants: PermissionGrantsInput!
}

input AppUpdateMutationInput {
  appID: String!
  userID: String!
  permissionsSettings: AppPermissionsSettingsInput
  clientMutationId: String
}

type AppUpdateMutationPayload {
  app: App
  viewer: User!
  clientMutationId: String
}

type AppUpdatePayload {
  app: App!
  viewer: User!
}

type AppVersion implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  appID: ID!
  app: App!
  developerID: ID!
  developer: Developer!
  manifest: AppManifest!
  installationState: AppInstallationState!
}

type Contact implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  peerID: ID!
  peer: Peer!
  publicID: String!
  profile: GenericProfile!
  connectionState: ContactConnectionState!
  invite: ContactInviteData
}

type ContactChangedPayload {
  contact: Contact!
  viewer: User!
}

enum ContactConnectionState {
  CONNECTED
  DECLINED
  RECEIVED
  SENDING_FEED
  SENT_FEED
  SENDING_BLOCKCHAIN
  SENT_BLOCKCHAIN
}

type ContactInviteData {
  inviteTX: String
  ethNetwork: String
  stake: ContactInviteStake!
}

type ContactInviteStake {
  amount: String
  state: ContactStakeState!
  reclaimedTX: String
}

type ContactRequest implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  localPeerID: ID!
  publicID: String!
}

enum ContactStakeState {
  STAKED
  RECLAIMING
  RECLAIMED
  SEIZED
}

input CreateDeveloperInput {
  profile: UserProfileInput!
  clientMutationId: String
}

type CreateDeveloperPayload {
  developer: OwnDeveloper
  viewer: User!
  clientMutationId: String
}

input CreateHDWalletInput {
  blockchain: SupportedWallets!
  name: String!
  setAsDefault: Boolean
  clientMutationId: String
}

type CreateHDWalletPayload {
  hdWallet: EthHDWallet
  viewer: User!
  clientMutationId: String
}

input DeleteContactInput {
  contactID: String!
  clientMutationId: String
}

type DeleteContactPayload {
  viewer: User!
  clientMutationId: String
}

input DeleteWalletInput {
  walletID: String!
  type: String!
  clientMutationId: String
}

type DeleteWalletPayload {
  viewer: User!
  clientMutationId: String
}

type Developer implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  profile: GenericProfile!
  publicID: ID!
  apps: [App!]!
}

type EthHDWallet implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  mnemonic: String!
  name: String
  accounts: [WalletAccount!]!
}

type EthLedgerWallet implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  name: String
  accounts: [WalletAccount!]!
}

type EthWallets {
  hd: [EthHDWallet!]!
  ledger: [EthLedgerWallet!]!
}

type GenericProfile {
  name: String
  avatar: String
  ethAddress: String
}

input ImportHDWalletInput {
  blockchain: SupportedWallets!
  mnemonic: String!
  name: String!
  setAsDefault: Boolean
  clientMutationId: String
}

type ImportHDWalletPayload {
  hdWallet: EthHDWallet
  viewer: User!
  clientMutationId: String
}

type Lookup {
  peerByID(publicID: String!): PeerLookupResult
}

input ManifestAuthorInput {
  id: String!
  name: String!
}

type Mutation {
  createApp(input: AppCreateMutationInput!): AppCreateMutationPayload
  createAppVersion(input: AppCreateVersionMutationInput!): AppCreateVersionMutationPayload
  installApp(input: AppInstallMutationInput!): AppInstallMutationPayload
  updateApp(input: AppUpdateMutationInput!): AppUpdateMutationPayload
  setAppPermissionsRequirements(input: SetAppPermissionsRequirementsInput!): SetAppPermissionsRequirementsPayload
  publishAppVersion(input: PublishAppVersionInput!): PublishAppVersionPayload
  updateAppDetails(input: UpdateAppDetailsInput!): UpdateAppDetailsPayload
  acceptContactRequest(input: AcceptContactRequestInput!): AcceptContactRequestPayload
  addContact(input: AddContactInput!): AddContactPayload
  createDeveloper(input: CreateDeveloperInput!): CreateDeveloperPayload
  deleteContact(input: DeleteContactInput!): DeleteContactPayload
  setProfileWallet(input: SetProfileWalletInput!): SetProfileWalletPayload
  setUserProfileVisibility(input: SetUserProfileVisibilityInput!): SetUserProfileVisibilityPayload
  updateProfile(input: UpdateProfileInput!): UpdateProfilePayload
  addHDWalletAccount(input: AddHDWalletAccountInput!): AddHDWalletAccountPayload
  addLedgerWalletAccounts(input: AddLedgerWalletAccountsInput!): AddLedgerWalletAccountsPayload
  createHDWallet(input: CreateHDWalletInput!): CreateHDWalletPayload
  deleteWallet(input: DeleteWalletInput!): DeleteWalletPayload
  importHDWallet(input: ImportHDWalletInput!): ImportHDWalletPayload
  setEthNetwork(input: SetEthNetworkInput!): SetEthNetworkPayload
}

type NamedProfile {
  name: String!
  avatar: String
  ethAddress: String
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type OwnApp implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  publicID: ID!
  developer: OwnDeveloper!
  profile: NamedProfile!
  contentsPath: String!
  versions: [OwnAppVersion!]!
  inProgressVersion: OwnAppVersion
  latestPublishedVersion: OwnAppVersion
}

type OwnAppVersion {
  version: String!
  contentsHash: String
  versionHash: String
  permissions: AppPermissionsRequirements!
}

type OwnDeveloper implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  profile: NamedProfile!
  publicID: ID!
  apps: [OwnApp!]!
}

type Peer implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  publicID: String!
  publicFeed: String!
  profile: GenericProfile!
}

type PeerLookupResult {
  publicKey: String
  publicID: String!
  profile: GenericProfile!
}

input PermissionGrantsInput {
  BLOCKCHAIN_SEND: Boolean
  COMMS_CONTACT: Boolean
  CONTACTS_READ: Boolean
  WEB_REQUEST: WebRequestGrantInput!
}

input PublishAppVersionInput {
  appID: String!
  version: String!
  clientMutationId: String
}

type PublishAppVersionPayload {
  versionHash: String!
  viewer: User!
  clientMutationId: String
}

type Query {
  lookup: Lookup!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
  viewer: User!
}

input SetAppPermissionsRequirementsInput {
  appID: String!
  permissionsRequirements: AppPermissionsRequirementsInput!
  clientMutationId: String
}

type SetAppPermissionsRequirementsPayload {
  viewer: User!
  clientMutationId: String
}

input SetEthNetworkInput {
  url: String!
  clientMutationId: String
}

type SetEthNetworkPayload {
  viewer: User!
  clientMutationId: String
}

input SetProfileWalletInput {
  address: String!
  clientMutationId: String
}

type SetProfileWalletPayload {
  viewer: User!
  clientMutationId: String
}

input SetUserProfileVisibilityInput {
  userID: String!
  visibile: Boolean
  clientMutationId: String
}

type SetUserProfileVisibilityPayload {
  viewer: User!
  clientMutationId: String
}

type Subscription {
  appUpdateChanged: AppUpdatePayload!
  contactChanged: ContactChangedPayload!
  contactsChanged: ContactChangedPayload!
}

enum SupportedWallets {
  ETHEREUM
}

input UpdateAppDetailsInput {
  appID: String!
  name: String!
  contentsPath: String!
  version: String!
  clientMutationId: String
}

type UpdateAppDetailsPayload {
  viewer: User!
  clientMutationId: String
}

input UpdateProfileInput {
  userID: String!
  profile: UpdateUserProfileInput!
  privateProfile: Boolean
  clientMutationId: String
}

type UpdateProfilePayload {
  viewer: User!
  clientMutationId: String
}

input UpdateUserProfileInput {
  name: String
  avatar: String
  ethAddress: String
}

type User implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  profile: NamedProfile!
  privateProfile: Boolean!
  publicID: ID!
  apps: [UserAppVersion!]!
  contacts: [Contact!]!
  contactRequests: [ContactRequest!]!
  ethWallets: EthWallets!
  ethURL: String!
  bzzURL: String!
}

type UserAppSettings implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  approvedContacts: [AppApprovedContact!]!
  defaultEthAccount: String
  permissionsChecked: Boolean!
  permissionsGrants: AppPermissions!
}

type UserAppVersion implements Node {
  """The ID of an object"""
  id: ID!
  localID: ID!
  userID: ID!
  user: User!
  appVersion: AppVersion!
  settings: UserAppSettings!
}

input UserProfileInput {
  name: String!
  avatar: String
}

type WalletAccount {
  address: String!
  balances: WalletBalances!
}

type WalletBalances {
  eth: String!
  mft: String!
}

input WebRequestGrantInput {
  granted: [String]
  denied: [String]
}

type WebRequestGrants {
  granted: [String!]!
  denied: [String!]!
}
